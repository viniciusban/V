#!/usr/bin/env bash
#
# V - Work effectively with virtualenvs

me=$(basename "$0")

_help () {
	cat <<-_EOF_
	Work with Python virtualenvs the right way.
	Usage: ${me} <command>
	where <command>:
	    help: show this screen and exit.
	    enter: enter the virtualenv in a subshell.
		where: show the virtualenv location.
	    gen: generate virtualenv path for current directory.
	_EOF_
}

_enter_virtualenv () {
	where="$1"
	commands=$(_build_commands_to_enter "$where")
	bash --init-file <(echo $commands)
}


_build_commands_to_enter () {
	#
	# You must add a semicolon to every command echoed.
	#
	where="$1"
	echo "echo 'Virtualenv location: $where';"

	if [[ -f $HOME/.bashrc ]]; then
	   	echo "source $HOME/.bashrc;"
	fi

	cat <<-_EOD_
		export VIRTUAL_ENV='${where}/bin';
		export PATH='${where}/bin:${PATH}';
		hash -r;
		python --version;
	_EOD_

	for file in {.env,.env.local}; do
		if [[ -r $file ]]; then
			cat <<-_EOD_
				echo 'Loading configuration file: $file';
				source $file;
			_EOD_
			break
		fi
	done
	echo "echo 'Type \"exit\" or press CTRL-D to exit';"
}


_discover_virtualenv () {
	declare -a std_locations
	std_locations=( \
		"$(_generate_path)" \
		"$(_generate_path --inline)")
	for path in "${std_locations[@]}"; do
		if [[ -d $path ]]; then
			echo $path
			return
		fi
	done

	declare -a legacy_locations
	legacy_locations=( \
		"$PWD/.venv" \
		"$PWD/venv" \
		"$PWD/.virtualenv")
	for path in "${legacy_locations[@]}"; do
		if [[ -d $path ]]; then
			echo $path
			return
		fi
	done

	return 1
}


_generate_path () {
	option="$1"
	hash=$(echo $PWD | sha1sum | cut -d' ' -f1 | cut -c1-7)
	hashed=("$(basename $PWD)_$hash")
	if [[ "$option" = "--inline" ]]; then
		prefix="$PWD"
	else
		prefix="$HOME/.local/share/virtualenvs"
	fi
	echo "${prefix}/$hashed"
}


_main () {
	while true; do
		case "$1" in
			gen )
				if [[ -z "$2" ]]; then
					option=
				elif [[ "$2" =~ ^(-i|--inline)$ ]]; then
					option=--inline
				else
					echo "Invalid option"
					return 1
				fi
				_generate_path $option
				return
			;;
			where )
				_discover_virtualenv
				return
			;;
			enter )
				if [[ -n "$2" ]]; then
					where="$2"
				else
					where="$(_discover_virtualenv)"
					if [[ -z "$where" ]]; then
						echo "There is no virtualenv related to this directory"
						return 1
					fi
				fi
				_enter_virtualenv "$where"
				return
			;;

			* )
				_help
				return
			;;
		esac
	done
}

_main "$@"
